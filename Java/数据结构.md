  Java 集合（容器）的优势在于它们的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。
# Collection 接口
## 分类
- List：有序可重复，对付顺序的好帮手
- Set：不可重复
- Queue：有序可重复，根据特定规则确定先后顺序
- 
## ArrayList 和 Array（数组）的区别？
- 动态（不指定大小） VS 静态（指定大小）
- 允许泛型 VS 不允许泛型
- 存储对象 VS 存储对象和基本数据类型
- 增删改查的丰富API VS 下标访问、修改
## ArrayList 初始容量以及扩容
初始容量是10， int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右

## ArrayList 与 LinkedList 区别?
LinkedList 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 
| ArrayList| LinkedList|
|----|----|
|线程不安全|线程不安全|
|Object数组|双向链表|
|尾部插入删除O(1)|头尾插入删除O(1)|
|快速随机访问|不支持|
|内存浪费在尾部的预留空间|浪费在前驱后继指针|

## LinkedList 为什么不能实现 RandomAccess 接口？
链表的内存地址不连续，只能通过指针定位，所以不支持随机访问

## HashSet、LinkedHashSet 和 TreeSet 三者的异同？
- HashSet:底层数据结构是哈希表，通过计算HashCode判断重复
- LinkedHashSet:链表+哈希表， 元素的插入删除满足FIFO
- TreeSet: 红黑树,元素自然排序和自定义排序
ArrayDeque 与 LinkedList 的区别
## PriorityQueue？
- 底层是可变数组，二叉堆的数据结构实现
- 插入删除满足O(logn)
- 非线程安全，不支持NULL和non-comparable
- 默认小顶堆，接受Comparator自定义元素顺序
  ```java
  import java.util.PriorityQueue;
  import java.util.Comparator;
  PriorityQueue <Integer> maxHeap = new PriorityQueue<Integer>(11, new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
      // TODO Auto-generated method stub
      return o2.compareTo(o1);
    }
  });
  ```
##  BlockingQueue？
阻塞队列，常用于生产者-消费者模型，实现的类：
- ArrayBlockingQueue：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制
- LinkedBlockingQueue：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue类似， 它也支持公平和非公平的锁访问机制
- PriorityBlockingQueue：支持优先级排序的无界阻塞队列。元素必须实现Comparable接口或者在构造函数中传入Comparator对象，并且不能插入 null 元素
- SynchronousQueue：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，SynchronousQueue通常用于线程之间的直接传递数据。DelayQueue：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。

# Map 接口
key-value,key不可重复，value可重复，每个key最多映射一个值
## 分类
- HashMap
- LinkedHashMap：继承自HashMap,增加了双向链表保证键值对的插入顺序
- HashTable：数组+链表
- TreeMap: 红黑树
## hashMap的实现原理
- JDK1.8前主要是数组加链表组成， 链表主要是解决hash冲突；
- 1.8后，当链表的长度大于默认值（8），将链表转换成红黑树前
  - 数组长度小于64，先数组扩容
  - 大于64，转换成红黑树（自平衡排序的二叉树）
## HashMap 和 HashTable的区别
||HashMap|HashTable|
|----|----|----|
|线程|不安全|安全|
|效率|高|低|
|NULL key|支持|不支持|
|初始容量不指定|16， 2n|11, 2n+1|
|初始容量指定|pow(2,n)|指定大小|
|底层数据结构|||
## HashMap 为什么线程不安全？
- jdk1.7 多线程扩容可能存在死循环，头插法可能会导致链表中的节点指向错误的位置，形成环形链表，jdk1.8采用尾插
- jdk.1.8后还是会存在数据覆盖问题
## ConcurrentHashMap 和 Hashtable？:
- HashTable:同一把锁,使用 synchronized 来保证线程安全
- jdk1.7:分段的数组（大数组 Segment 和小数组 HashEntry）+链表，对桶数组进行分段，每个分段一把锁，提高并发
- jdk1.8：Node数组+链表+红黑树，并发控制使用synchronized+CAS操作，只锁定当前链表或红黑树的头节点，锁的粒度更小

## HashMap 的长度为什么是 2 的幂次方
- 提高运算效率：hash % length == hash & (length - 1)
- 分布均匀
## hashMap 如何解决hash冲突

## hashMap 如何扩容


