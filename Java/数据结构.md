  Java 集合（容器）的优势在于它们的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。
# Collection 接口
## 分类
- Set：不可重复
- List：有序可重复，对付顺序的好帮手
- Queue：有序可重复，根据特定规则确定先后顺序
## ArrayList 和 Array（数组）的区别？
- 动态（不指定大小） VS 静态（指定大小）
- 允许泛型 VS 不允许泛型
- 存储对象 VS 存储对象和基本数据类型
- 增删改查的丰富API VS 下标访问、修改
## ArrayList 初始容量以及扩容
初始容量是10， int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右

## ArrayList 与 LinkedList 区别?
LinkedList 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 
| ArrayList| LinkedList|
|----|----|
|线程不安全|线程不安全|
|Object数组|双向链表|
|插入删除元素位置|插入删除元素位置|
|快速随机访问|不支持|
|内存浪费在尾部的预留空间|浪费在前驱后继指针|

## LinkedList 为什么不能实现 RandomAccess 接口？
链表的内存地址不连续，只能通过指针定位，所以不支持随机访问

# Map 接口
key-value,key不可重复，value可重复，每个key最多映射一个值
## 分类
- HashMap
- LinkedHashMap：继承自HashMap,增加了双向链表保证键值对的插入顺序
- HashTable：数组+链表
- TreeMap: 红黑树
## hashMap的实现原理
- JDK1.8前主要是数组加链表组成， 链表主要是解决hash冲突；
- 1.8后，当链表的长度大于默认值（8），将链表转换成红黑树前
  - 数组长度小于64，先数组扩容
  - 大于64，转换成红黑树（自平衡排序的二叉树）
## LinkedHashMap
继承自HashMap,增加了双向链表保证键值对的插入顺序
# hashMap 如何解决hash冲突

# hashMap 如何扩容


