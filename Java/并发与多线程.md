# 什么是线程和进程?
- 进程是程序执行的一次过程，是系统运行程序、资源分配的基本单位
- 线程是进程中的一条执行流程，CPU调度的最小单位。例如视频播放
- 一个进程可以多个线程，多个线程共享进程中的堆和方法区，每个线程有自己的
  - 程序计数器（线程切换能恢复到正确位置）
  - 虚拟机栈
  - 本地方法栈
# 并发与并行、同步与异步、互斥、阻塞、非阻塞
- 互斥：多个线程访问同一片内存资源只有一个线程能够获得访问权
- 同步和异步是针对两个线程的、两个线程之间要么是同步，要么是异步的
- 阻塞和非阻塞是针对同一个线程的
https://cloud.tencent.com/developer/article/1829301
# 多线程的优缺点？
- 优:提高执行效率和程序运行速度
- 缺：线程不安全（同一份数据的一致性）、内存泄露、死锁

# 线程的生命周期和状态？
- New
- Runnable
- blocked:阻塞状态，需要等待锁释放。
- waiting:等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
- time_waiting
- terminated
  
# 什么是线程的上下文切换？
线程在执行的过程中会有自己的状态和信息，如程序计数器和栈信息，当出现
- 主动让出CPU，调用了sleep(),wait()
- 时间片用完
- 调用了系统中断线程被阻塞
线程需要切换要保存当前线程的上下文，留到下次CPU调用时候恢复信息
# 什么是线程死锁?如何避免死锁?
多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。死锁的必要条件：
- 破坏请求和保持：一次性申请所有资源
- 破坏不可剥夺：占用部分资源的进程进一步申请其他资源时，申请不到，主动释放自己占有的
- 破坏循环等待：按序申请资源，反序释放
- 避免：资源有序分配

  
# volatile关键字
- 保证了变量的可见性，共享不稳定的，每次都得去主内存进行读取
- 防止JVM指令重排序（多线程指令执行顺序不同带来的正确性）
- 不能保证对变量操作的原子性，改进：synchronized、Lock或者AtomicInteger
# 乐观锁和悲观锁
## 悲观锁：
  - 定义：假设最坏的情况，对于共享资源，只给一个线程使用，其他线程阻塞，用完再转给其他线程。
  - 实现:synchronized, reentrantLock等独占锁
  - 缺点：会出现大量线程阻塞导致系统的上下文切换，增加系统的开销，还可能存在死锁的问题
## 乐观锁：
  - 定义：考虑最好的情况，认为共享资源每次访问时候不会出现问题，多个线程可以不停执行修改，无需加锁也无需等待，只需要在提交的阶段验证资源是否被其他线程修改。
  - 实现：版本号机制和CAS【Compare and swap】）算法、原子变量类（比如AtomicInteger、LongAdder）。
  - 优点：是高并发，缺点是写比较多的情况下会频繁失败和重试，导致CPU飙升
  - 问题：
    - ABA---追加版本号或时间戳
    - 循环时间长开销大---pause指令
    - 只能保证一个共享变量的原子操作----AtomicReference类多个共享变量合并成一个共享变量来操作
# 公平锁和非公平锁有什么区别？
- 公平：锁释放后，先申请的先获得，保证了时间上的绝对顺序， 频繁的上下文切换，性能差
- 非公平：锁释放后，后申请的线程可能先获得，或者按照某种指定顺序，性能好，但是有些线程可能永远获取不了锁
# synchronized 关键字
解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行
- 修饰实例方法 （锁当前对象实例） synchronized void method()
- 修饰静态方法 （锁当前类）synchronized static void method()
- 修饰代码块 （锁指定对象/类）
底层原理：monitor、进入同步块、锁定状态、等待状态、释放锁
# ReentrantLock 是什么？
- 定义：实现了 Lock 接口，是一个可重入且独占式的锁，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能
# synchronized 和 ReentrantLock 有什么区别？
- 两者都是可重入锁，线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的
- ReentrantLock增加的功能：
  - 等待：等待的线程可以不等待改为去处理其他事情
  - 可中断：获取锁的过程可以被中断，syn属于不可中断
  - 可实现公平锁，syn只能非公平
  - 可实现选择性通知
# ReentrantReadWriteLock
其实是两把锁，一把是 WriteLock (写锁)，一把是读锁， ReadLock 。读写锁的规则是：读读不互斥、读写互斥、写写互斥可重入的读写锁，保证了多个线程的同时读，也保证了写入时候的线程安全

# ThreadLocal 有什么用？
- 作用：让每个线程都有自己的私有数据、本地副本，而不影响其他线程的副本
- 原理：ThreadLocal 底层是一个 ThreadLocalMap的哈希表，每个线程都有相关的 ThreadLocalMap， key是ThreadLocal的实例， value 是本地变量副本的值，里面有get() set() 方法
- 内存泄露问题： key是弱引用， value是强引用，垃圾回收时，key被清理掉出现null值，value没有被清理。所以实际上ThreadLocal调用set（）、get()方法时候会清理掉null的key值

# 线程池
- 定义：管理一系列线程的资源池。有任务要处理时，直接从线程池中获取线程处理，处理后的线程不会被立刻销毁，而是等待下一次任务
- 优点：
  - 降低资源消耗
  - 提高响应速度
  - 提高线程的可管理
- 创建：
  - ThreadPoolExecutor 构造函数来创建（推荐）
  - Executor 框架的工具类 Executors 来创建
- ThreadPoolExecutor 常见参数：
  - corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量
  - maximumPoolSize: 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
  - workQueue：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
  - keepAliveTime: 线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；



























