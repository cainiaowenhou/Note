# 什么是线程和进程?
- 进程是程序执行的一次过程，是系统运行程序、资源分配的基本单位
- 线程是进程中的一条执行流程，CPU调度的最小单位。例如视频播放
- 一个进程可以多个线程，多个线程共享进程中的堆和方法区，每个线程有自己的
  - 程序计数器（线程切换能恢复到正确位置）
  - 虚拟机栈
  - 本地方法栈
# 并发与并行、同步与异步、互斥、阻塞、非阻塞
- 互斥：多个线程访问同一片内存资源只有一个线程能够获得访问权
- 同步和异步是针对两个线程的、两个线程之间要么是同步，要么是异步的
- 阻塞和非阻塞是针对同一个线程的
https://cloud.tencent.com/developer/article/1829301
# 多线程的优缺点？
- 优:提高执行效率和程序运行速度
- 缺：线程不安全（同一份数据的一致性）、内存泄露、死锁

# 线程的生命周期和状态？
- New：初始状态，线程被创建出来还没被调用start()'
- Runnable:运行状态，调用了 start()
- blocked:阻塞状态，需要等待锁释放。
- waiting:等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
- time_waiting：可以在指定时间内自行返回而不是一直waiting
- terminated:终止状态
  
# 什么是线程的上下文切换？
线程在执行的过程中会有自己的状态和信息，如程序计数器和栈信息，当出现
- 主动让出CPU，调用了sleep(),wait()
- 时间片用完
- 调用了系统中断线程被阻塞
线程需要切换要保存当前线程的上下文，留到下次CPU调用时候恢复信息

# 什么是线程死锁?如何避免死锁?
多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。死锁的必要条件：
- 破坏请求和保持：一次性申请所有资源
- 破坏不可剥夺：占用部分资源的进程进一步申请其他资源时，申请不到，主动释放自己占有的
- 破坏循环等待：按序申请资源，反序释放
- 避免：资源有序分配

# volatile关键字
- 保证了变量的可见性，共享不稳定的，每次都得去主内存进行读取
- 防止JVM指令重排序（多线程指令执行顺序不同带来的正确性）
- 不能保证对变量操作的原子性，改进：synchronized、Lock或者AtomicInteger

# 乐观锁和悲观锁
## 悲观锁：
  - 定义：假设最坏的情况，对于共享资源，只给一个线程使用，其他线程阻塞，用完再转给其他线程。
  - 实现:synchronized, reentrantLock等独占锁
  - 缺点：会出现大量线程阻塞导致系统的上下文切换，增加系统的开销，还可能存在死锁的问题
## 乐观锁：
  - 定义：考虑最好的情况，认为共享资源每次访问时候不会出现问题，多个线程可以不停执行修改，无需加锁也无需等待，只需要在提交的阶段验证资源是否被其他线程修改。
  - 实现：版本号机制和CAS【Compare and swap】）算法、原子变量类（比如AtomicInteger、LongAdder）。
  - 优点：是高并发，缺点是写比较多的情况下会频繁失败和重试，导致CPU飙升
  - 问题：
    - ABA---追加版本号或时间戳
    - 循环时间长开销大---pause指令
    - 只能保证一个共享变量的原子操作----AtomicReference类多个共享变量合并成一个共享变量来操作
# 公平锁和非公平锁有什么区别？
- 公平：锁释放后，先申请的先获得，保证了时间上的绝对顺序， 频繁的上下文切换，性能差
- 非公平：锁释放后，后申请的线程可能先获得，或者按照某种指定顺序，性能好，但是有些线程可能永远获取不了锁
# synchronized 关键字
解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行
- 修饰实例方法 （锁当前对象实例） synchronized void method()
- 修饰静态方法 （锁当前类）synchronized static void method()
- 修饰代码块 （锁指定对象/类）
底层原理：monitor、进入同步块、锁定状态、等待状态、释放锁
# ReentrantLock 是什么？
- 定义：实现了 Lock 接口，是一个可重入且独占式的锁，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能
# synchronized 和 ReentrantLock 有什么区别？
- 两者都是可重入锁，线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的
- ReentrantLock增加的功能：
  - 等待：等待的线程可以不等待改为去处理其他事情
  - 可中断：获取锁的过程可以被中断，syn属于不可中断
  - 可实现公平锁，syn只能非公平
  - 可实现选择性通知
# ReentrantReadWriteLock
其实是两把锁，一把是 WriteLock (写锁)，一把是读锁， ReadLock 。读写锁的规则是：读读不互斥、读写互斥、写写互斥可重入的读写锁，保证了多个线程的同时读，也保证了写入时候的线程安全

# ThreadLocal 有什么用？
- 作用：让每个线程都有自己的私有数据、本地副本，而不影响其他线程的副本
- 原理：ThreadLocal 底层是一个 ThreadLocalMap的哈希表，每个线程都有相关的 ThreadLocalMap， key是ThreadLocal的实例， value 是本地变量副本的值，里面有get() set() 方法
- 内存泄露问题： key是弱引用， value是强引用，垃圾回收时，key被清理掉出现null值，value没有被清理。所以实际上ThreadLocal调用set（）、get()方法时候会清理掉null的key值

# 线程池
- 定义：管理一系列线程的资源池。有任务要处理时，直接从线程池中获取线程处理，处理后的线程不会被立刻销毁，而是等待下一次任务
- 优点：
  - 降低资源消耗
  - 提高响应速度
  - 提高线程的可管理：线程是稀缺资源，如果无限制的创建。可以进行统一的分配，调优和监控
- 创建：
  - ThreadPoolExecutor 构造函数来创建（推荐）
  - Executor 框架的工具类 Executors 来创建
- ThreadPoolExecutor 常见参数：
  - corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量
  - maximumPoolSize: 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
  - workQueue：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
  - keepAliveTime: 线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；
- 阻塞队列：
  - LinkedBlockingQueue ：
  - SynchronousQueue ：
  - DelayedWorkQueue ：
  
- 饱和策略：
  - ThreadPoolExecutor.AbortPolicy
  - ThreadPoolExecutor.CallerRunsPolicy： 它既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务
  - ThreadPoolExecutor.DiscardPolicy
  - ThreadPoolExecutor.DiscardOldestPolicy
  - 
- 处理任务流程
- 线程池大小的设置
  太小会导致大量请求排队等待无法处理，太大大量线程会争取CPU资源导致频繁的上下文切换
  - CPU密集型任务:N+1
  - I/O密集型任务：2N
- 动态修改线程池的参数？
  https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html

# Java 内存区域详解
## 堆空间基本结构
Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。
在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：
- 新生代内存(Young Generation)
- 老生代(Old Generation)
- 永久代(Permanent Generation)：8后被元空间Metaspace取代，元空间
## 内存分配和回收原则
- 对象优先在Eden区分配
- 大对象直接进入老年代：大量连续内存空间的对象（比如：字符串、数组）
- 长期存活的对象将进入老年代：每个对象分配了年龄计数器
- 主要进行gc的区域
  - 部分收集 (Partial GC)：
    - 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
    - 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。
    - 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集
  - 整堆收集 (Full GC)：收集整个 Java 堆和方法区

- 空间分配担保

## 死亡对象判断方法
- 引用计数器： 无法解决循环引用的问题
- 可达性计数器：通过GC Roots作为根节点，往下遍历，节点走过的路径称为引用链，当一个对象到GC Roots无任何引用链的话，证明该对象不可用
- 弱引用、软引用、虚引用

## 垃圾收集算法
- 标记-清除算法
- 标记-复制算法
- 标记-整理算法
- 分代收集算法：

## 为什么分新生代和老年代？
优化垃圾回收和内存管理。新生代存放新创建的对象，大部分都会变得不可达，使用标记复制算法回收；老年代存活时间较长，可以使用标记清除或者标记整理的算法
  



























