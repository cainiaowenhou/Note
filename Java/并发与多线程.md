# 什么是线程和进程?
- 进程是程序执行的一次过程，是系统运行程序、资源分配的基本单位
- 线程是进程中的一条执行流程，CPU调度的最小单位。例如视频播放
- 一个进程可以多个线程，多个线程共享进程中的堆和方法区，每个线程有自己的
  - 程序计数器（线程切换能恢复到正确位置）
  - 虚拟机栈
  - 本地方法栈
# 并发与并行、同步与异步、互斥、阻塞、非阻塞
- 互斥：多个线程访问同一片内存资源只有一个线程能够获得访问权
- 同步和异步是针对两个线程的、两个线程之间要么是同步，要么是异步的
- 阻塞和非阻塞是针对同一个线程的
https://cloud.tencent.com/developer/article/1829301
# 多线程的优缺点？
- 优:提高执行效率和程序运行速度
- 缺：线程不安全（同一份数据的一致性）、内存泄露、死锁

# 线程的生命周期和状态？
- New
- Runnable
- blocked:阻塞状态，需要等待锁释放。
- waiting:等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
- time_waiting
- terminated
  
# 什么是线程的上下文切换？
线程在执行的过程中会有自己的状态和信息，如程序计数器和栈信息，当出现
- 主动让出CPU，调用了sleep(),wait()
- 时间片用完
- 调用了系统中断线程被阻塞
线程需要切换要保存当前线程的上下文，留到下次CPU调用时候恢复信息
# 什么是线程死锁?如何避免死锁?
多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。死锁的必要条件：
- 破坏请求和保持：一次性申请所有资源
- 破坏不可剥夺：占用部分资源的进程进一步申请其他资源时，申请不到，主动释放自己占有的
- 破坏循环等待：按序申请资源，反序释放
- 避免：资源有序分配

  
# volatile关键字
- 保证了变量的可见性，共享不稳定的，每次都得去主内存进行读取
- 防止JVM指令重排序（多线程指令执行顺序不同带来的正确性）
- 不能保证对变量操作的原子性，改进：synchronized、Lock或者AtomicInteger
# 乐观锁和悲观锁
## 悲观锁：
  - 定义：假设最坏的情况，对于共享资源，只给一个线程使用，其他线程阻塞，用完再转给其他线程。
  - 实现:synchronized, reentrantLock等独占锁
  - 缺点：会出现大量线程阻塞导致系统的上下文切换，增加系统的开销，还可能存在死锁的问题
## 乐观锁：
  - 定义：考虑最好的情况，认为共享资源每次访问时候不会出现问题，多个线程可以不停执行修改，无需加锁也无需等待，只需要在提交的阶段验证资源是否被其他线程修改。
  - 实现：版本号机制和CAS【Compare and swap】）算法、原子变量类（比如AtomicInteger、LongAdder）。
  - 优点：是高并发，缺点是写比较多的情况下会频繁失败和重试，导致CPU飙升
  - 问题：
    - ABA---追加版本号或时间戳
    - 循环时间长开销大---pause指令
    - 只能保证一个共享变量的原子操作----AtomicReference类多个共享变量合并成一个共享变量来操作
# synchronized 关键字
解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行
- 修饰实例方法 （锁当前对象实例） synchronized void method()
- 修饰静态方法 （锁当前类）synchronized static void method()
- 修饰代码块 （锁指定对象/类）
底层原理：monitor、进入同步块、锁定状态、等待状态、释放锁
 

























