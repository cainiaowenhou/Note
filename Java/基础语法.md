## Java语言的特点/ Java和C++的 区别？
1. 面向对象的
2. 多线程的， C++ 必须调用操作系统的多线程功能；
3. 安全的， 使用引用（.）而不是指针(& -> *)， 如：
   ```java
   public class Student{
      public Integer sex;
      public Integer age;
    
      Student(Integer s, Integer a) {
          sex = s;
          age = a;
      }
   }
    Student stu1 = new Student(1, 20); // 创建一个引用stu1，stu1中存储的不是对象的数据，而是是对象的地址，也即引用
                                   // stu1存放在stack，对象存放在heap
   ```
5. 自动内存管理和垃圾回收机制，无需手动释放内存

## continue、break 和 return 的区别是什么？
- continue：指跳出当前的这一次循环，继续下一次循环;
- break：指跳出整个循环体，继续执行循环下面的语句。return 用于跳出所在方法，结束该方法的运行
- return 一般有两种用法：
  return;：直接使用 return 结束方法执行，用于没有返回值函数的方法;
  return value;：return 一个特定值，用于有返回值函数的方法


## 8种基本数据类型？
- boolean(1)
- byte(8)
- short(16, -32768 ~ 32767)
- char(16, 0 ~ 65535)
- int（32）
- long（64）
- float(32)
- double(64)
float需要加f；使用long需要加上后缀L,否则会作为int解析  如：
``` java
float myFloat = 1.5f;
long myLong = 1234567L;
```
另外，浮点数运算存在精度损失的问题， 对浮点数精确运行的业务场景可以使用BigDecimal
## 基本类型和包装类型
### 为什么需要包装类型？
   Java 是面向对象的，基本类型没有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。另外，当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的包装器类了。
### 两者的相互转换
```java
int i=0;
Integer ii = new Integer(i);
int i = ii.intValue();
```
### 存储方式
基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
### 占用空间
相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
### 默认值
包装类型不赋值就是 null ，而基本类型有默认值（int 为0， boolean为false）且不是 null。
### 比较方式
对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。
### 缓存机制
利用缓存机制提升性能，实现方式是在类初始化时候提前创建好频繁使用的包装类对象，如果值在缓存范围内（Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False），则直接返回，否则新创建一个对象返回。

## 静态变量和静态方法
- 静态变量可以被类的所有实例共享，只分配一次内存；
- 静态方法不能调用非静态成员：静态方法在类加载时候已经分配了内存， 非静态成员在实例初始化后才存在，需要类的实例对象去访问；
- 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制
- 外部可以使用 类名.方法名 或者 对象.方法名 的方式调用静态方法


## 创建一个对象用什么运算符？ 对象实例和对象引用有何不同？
- new运算符，创建对象实例（对象实例在 内存中），对象引用指向对象实例（对象引用存放在栈内存中）
- 引用：绳子，对象：气球。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。

## 对象相等和引用相等的区别
- 对象相等是指对象存储的内容是否相等；
- 引用相等是指引用所指向的内存地址是否相等

## ==和equals() 的区别
- ==对于基本数据类型来说，== 比较的是值
- ==对于引用数据类型来说，== 比较的是对象的内存地址
- equals()用来判断两个对象是否相等
   - 类没有重写 equals()方法：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法
   - 类重写了 equals()方法：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等。
   - String被重写了

## String、 StringBuffer、StringBuilder 的区别
- String ：不可变，线程安全，使用final 关键字修饰字符数组保存字符串， 操作少量数据
- StringBuilder ： 多线程不安全，单线程操作大量数据
- StringBuffer： 多线程安全（加了同步锁），多线程操作大量数据

字符串拼接使用StringBuilder 更高效，只需要在循环外部创建一次；String s+=val, 每次都会创建一个StringBuilder

## 字符串常量池与String s1 = new String("abc");这句话创建了几个字符串对象？
作用，提升性能，减少内存消耗，避免字符串重复创建
- 2个，引用不在常量池中，先在常量池中创建，再在堆中创建；
- 1个，引用在常量池中，直接在堆中创建

## String # intern() 方法的作用
指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：
- 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用
- 如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。

## String 类型的变量和常量做“+”运算时发生了什么？
``` java
String str1 = "str";
String str2 = "ing";
String str3 = "str" + "ing";
String str4 = str1 + str2;
String str5 = "string";
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false

final String str1 = "str";
final String str2 = "ing";
// 下面两个表达式其实是等价的
String c = "str" + "ing";// 常量池中的对象
String d = str1 + str2; // 常量池中的对象
System.out.println(c == d);// true
``` 
## 抽象类的特点
- 如果一个类中有抽象方法，那么这个类一定是抽象类
- 抽象类中不一定有抽象方法
- 抽象类中可以存在抽象方法
- 抽象类中可以存在构造方法
- 抽象类中可以存在普通属性、方法、静态属性和静态方法
- 抽象类中的抽象方法需要有子类实现，如果子类不实现，则子类也需要定义为抽象的

## java中接口的特点：
- 接口中的方法，永远都被public来修饰
- 接口中没有构造方法，也不能实例化接口对象
- 接口中只有方法的声明，没有方法体
- 接口中只有常量，如果定义变量，在编译的时候都会默认加上“public static final”
- 接口中定义的方法都需要实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需要定义为抽象类
- 静态方法不能被子类重写（覆盖），因此接口中不定声明静态方法
- 使用接口可以实现多继承
