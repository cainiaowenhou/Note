# 什么是Redis?
- 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。
- 高性能、高并发（10wQPS）  
# Redis 和 Memcached 有什么区别？
- 丰富的数据类型：String、Hash、List、Set、ZSet， Memcached 只支持最简单的 key-value 数据类型
- 数据持久化：内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用
- 支持集群模式：
- 发布订阅模型、Lua 脚本、事务等功能
# 常用数据结构和使用场景
- 字符串（String）：缓存数据、计数器、分布式锁、存储用户会话信息。
- 哈希表（Hash）：存储和管理对象的字段和值，如用户信息、配置信息。
- 列表（List）：实现消息队列、存储最新的数据、记录日志。
- 集合（Set）：存储唯一值，如用户标签、共同好友、投票系统中的候选项。
- 有序集合（ZSet）：排行榜、按分数范围获取数据、实时热门内容。
- 位图（BitMap）：处理标志位、统计用户在线时长、进行布隆过滤器等。
- 地理空间索引（Geospatial Index）：地理位置相关的应用，如附近的人、地点检索、地理围栏。
- HyperLogLog：估算基数（去重后的元素数量），如统计网站的独立访客数。
- 布隆过滤器（Bloom Filter）：检查元素是否可能存在于集合中，用于缓存预热、爬虫去重等。
- 带有过期时间的键（Expiring Keys）：设置缓存的过期时间，实现自动数据清理。
- 发布/订阅（Pub/Sub）：实现消息发布和订阅模型，用于实时通信、事件驱动系统。
- Lua脚本：执行复杂的原子操作，实现事务、自定义命令等。
# 如何实现持久化？
Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。
- AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。
- RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以
- 混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；

# 过期删除策略》
- 惰性删除：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key；优点是对CPU友好，缺点是一直占用内存
- 定期删除：每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。优点是通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。
# 内存淘汰策略？
- 不进行数据淘汰
- 进行数据淘汰的策略
  - volatile-random：随机淘汰设置了过期时间的任意键值；
  - volatile-ttl：优先淘汰更早过期的键值。
  - volatile-lru（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
  - volatile-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；
# 如何避免缓存雪崩、缓存击穿、缓存穿透？
|缓存异常|产生原因|解决方法|
|----|----|----|
|缓存雪崩|大量数据同时过期|均匀设置过期时间，避免同一时间过期；互斥锁，保证同一时间只有一个应用在构建缓存；后台更新缓存，定时更新、消息队列通知更新|
|缓存雪崩|Redis 故障宕机|服务熔断；请求限流；构建redis缓存高可靠集群|
|缓存击穿|频繁访问的热点数据过期|互斥锁：保证同一时间只有一个业务线程更新缓存；不给热点数据设置过期时间，由后台异步更新缓存|
|缓存穿透|访问的数据既不在缓存，也不在数据库|非法请求的限制；缓存空值和null值；布隆过滤器快速判断数据是否存在|
# 内存和数据库一致性?
## 先更新数据库，还是先更新缓存？ 这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。解决方法
- 在更新缓存前先加个分布式锁，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。
- 在更新完缓存时，给缓存加上较短的过期时间，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的
## 先更新数据库，还是先删除缓存？
- 先删除缓存，再更新数据库
  - 「延迟双删」。
- 先更新数据库，再删除缓存：缓存的写入通常要远远快于数据库的写入，可以保证缓存的一致性，但是每次更新数据的时候，缓存的数据都会被删除，这样会对缓存的命中率带来影响。保证两个操作的一致性？
  - 重试机制：引入消息队列，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。
  - 订阅 MySQL binlog，再操作缓存
  - 这两种方法有一个共同的特点，都是采用异步操作缓存。

  

