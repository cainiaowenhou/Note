
# MYSQL连接过程
- 连接器：建立连接，管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；
# MySQL的compact 行格式长什么样？
- 记录的额外信息
  - 变长字段长度列表
  - NULL 值列表
  - 记录头信息
- 记录的真实数据
  - row_id、trx_id、roll_pointer
  - 定义的字段
# MySQL 的 NULL 值是怎么存放的？
- MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。
- NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。
# varchar(n) 中 n 最大取值为多少？
- 一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数】，计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数
# 行溢出后，MySQL 是怎么处理的？
- 如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中
- 记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。
# 什么是索引？
索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。
# 索引的数据结构B+树
- vs 二叉树：数据量高时二叉树的高度很高，B+树在千万级别近维持在3-4层，磁盘的IO少
- vs B树：B+树非叶子节点不存放实际的记录数据，仅存放索引，相同数据量的时候B+树的树高更低；叶子节点用双向链表串起来适合范围查询
# 什么时候需要创建索引？
- 字段有唯一性限制的，比如商品编码、时间戳
- 经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引
- 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的
# 什么时候不需要创建索引？
- where、group by、order by 用不到的字段
- 字段中存在大量重复数据，例如性别只有男女
- 表中的数据太少
- 经常需要更新的数据
# 什么时候索引失效？
- 使用左或者左右模糊匹配的时候，也就是“like%xx或者like%xx%这两种方式都会造成索引失效;
- 当我们在查询条件中对索引列做了计算、函数、类型转换操作，会导致索引失效
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效
- 在WHERE子句中，如果在OR前的条件列是索引列而在OR后的条件列不是索引列，那么索引会失效。为了更好的利用索引，索引列要设置为NOTNULL约束。
# 索引的优化策略？
- 前缀索引优化：某个字段中字符串的前几个字符建立索引， 在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小
- 覆盖索引优化;
- 主键索引最好是自增的;
- 防止索引失效;
  
# 事务隔离级别？

# 为什么产生死锁？
